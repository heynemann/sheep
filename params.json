{"name":"Sheep","tagline":"sheep is a worker console app generator.","body":"sheep\r\n=====\r\n\r\nsheep is a `dead-simple` worker process manager.\r\n\r\nWhy?\r\n----\r\n\r\nWriting worker processes that do background processing is a fairly common task.\r\n\r\nAt the time sheep was created there was no available solution to the requirements.\r\n\r\nRequirements\r\n------------\r\n\r\nsheep must be able to:\r\n\r\n* Easy to use configuration (sheep uses [derpconf](https://github.com/globocom/derpconf));\r\n* Easy to fork (spawning multiple workers with a single command);\r\n* Reliability when running an unit-of-work (must not die even in the face of SEGFAULT);\r\n* Ease-of-use (Implementing a new worker must be really simple).\r\n\r\nWithout further ado, let's see how to implement and use sheep.\r\n\r\nInstalling\r\n----------\r\n\r\nInstalling is as easy as:\r\n\r\n    $ pip install sheep\r\n\r\nThe Shepherd\r\n------------\r\n\r\nThe class required to run sheep is the `Shepherd`. All you need to do is subclass it like this:\r\n\r\n```python\r\nfrom sheep import Shepherd\r\n\r\nclass MyWorker(Shepherd):\r\n    def do_work(self):\r\n        # do some heavy work\r\n        print(\"Done\")\r\n\r\nif __name__ == \"__main__\":\r\n    MyWorker.run()\r\n```\r\n\r\nSave this in a file called `my_worker.py`. Then running your new worker is as easy as:\r\n\r\n    $ python my_worker.py\r\n\r\nYou can see all the options with `--help`:\r\n\r\n    $ python my_worker.py --help\r\n\r\nHow to add my own configuration keys?\r\n-------------------------------------\r\n\r\nSince sheep uses [derpconf](https://github.com/globocom/derpconf), all you need to do is create a file with the configuration keys for your application. We'll call this file `my_worker.conf` for this example:\r\n\r\n```python\r\n# the configuration names MUST be in Uppercase, otherwise derpconf will ignore them\r\nCONFIG1 = \"test\"\r\nCONFIG2 = \"other\"\r\n```\r\n\r\nWhen invoking your `Shepherd`, just use the `--config` option:\r\n\r\n    $ python my_worker.py --config=./my_worker.conf\r\n\r\nThen in your `Shepherd` those become available via the `config` property:\r\n\r\n```python\r\nfrom sheep import Shepherd\r\n\r\nclass MyWorker(Shepherd):\r\n    def do_work(self):\r\n        # do some heavy work\r\n        print(self.config.CONFIG1)  # prints \"test\"\r\n        print(self.config.CONFIG2)  # prints \"other\"\r\n\r\nif __name__ == \"__main__\":\r\n    MyWorker.run()\r\n```\r\n\r\nHow to add default values for configuration keys?\r\n-------------------------------------------------\r\n\r\nSubclassing [derpconf's](https://github.com/globocom/derpconf) `Config` class you can specify defaults for your keys. Just create a `config.py` file with something like this:\r\n\r\n```python\r\nfrom derpconf.config import Config\r\n\r\nConfig.define('foo', 'fooval', 'Foo is always a foo', 'FooValues')\r\n```\r\n\r\nNow, all that you need to do is tell your `Shepherd` where he can find your `Config` class:\r\n\r\n```python\r\nfrom sheep import Shepherd\r\nfrom config import Config\r\n\r\nclass MyWorker(Shepherd):\r\n    def get_config_class(self):\r\n        return Config  # just return the class type and Shepherd will take care of the rest\r\n\r\n    def do_work(self):\r\n        # do some heavy work\r\n        print(self.config.foo)  # prints \"fooval\" even if no config file specified or key not found in config file\r\n\r\nif __name__ == \"__main__\":\r\n    MyWorker.run()\r\n```\r\n\r\nHow to change my worker's name?\r\n------------------------------\r\n\r\nYou should override the `get_description` method in your `Shepherd` in order to get better logging messages when running your worker.\r\n\r\nJust return whatever text you want to be used as the name of your parent worker.\r\n\r\n```python\r\nfrom sheep import Shepherd\r\n\r\nclass MyWorker(Shepherd):\r\n    def get_description(self):\r\n      return \"My Funky Worker v1.0.0\"\r\n\r\n    def do_work(self):\r\n        # do some heavy work\r\n        print(\"Done\")\r\n\r\nif __name__ == \"__main__\":\r\n    MyWorker.run()\r\n```\r\n\r\nHow to add arguments?\r\n---------------------\r\n\r\nAs with the arguments you can already pass to your `Shepherd`, you can add more of your own. Just override the `config_parser` method:\r\n\r\n```python\r\nfrom sheep import Shepherd\r\n\r\nclass MyWorker(Shepherd):\r\n    def config_parser(self, parser):\r\n      # parser is an instance of argparse.ArgumentParser\r\n      # just use the regular argparse configuration methods\r\n      parser.add_argument('--foo', help='foo help')\r\n\r\n    def do_work(self):\r\n        # do some heavy work\r\n        print(\"Done\")\r\n\r\nif __name__ == \"__main__\":\r\n    MyWorker.run()\r\n```\r\n\r\nNow `my_worker.py` can be called with `--foo`:\r\n\r\n    $ python my_worker.py --foo\r\n\r\nWhat if my worker raises an exception?\r\n--------------------------------------\r\n\r\n<blockquote>Contrary to what you may have heard or even expressed yourself, sheep are not stupid. (<a href=\"http://www.livestocktrail.illinois.edu/sheepnet/paperDisplay.cfm?ContentID=1\">An Introduction to Sheep Behavior - Richard Cobb</a>).</blockquote>\r\n\r\nIf your `do_work` method raises any exceptions, your `Shepherd` will log it to the standard output and run `do_work` again. Sheep won't let your worker die in the face of an exception.\r\n\r\n\"What if it gets a SEGFAULT error while doing its work?\", you'll ask. Well, we are prepared for that. If the fork that's running your work dies, sheep will revive it and start running it again.\r\n\r\nHow to Contribute\r\n-----------------\r\n\r\nFork, branch, pull request. Same ol', same ol'.\r\n\r\nLicense\r\n-------\r\n\r\nLook at the LICENSE file.\r\n","google":"UA-45664610-1","note":"Don't delete this file! It's used internally to help with page regeneration."}